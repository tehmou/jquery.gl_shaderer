<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

    <title>Fragment Shader Gallery</title>

    <link rel="stylesheet" href="index.css">

    <script id="plain-fs" type="shader-fs">
// Some boilerplate code.
#ifdef GL_ES
precision highp float;
#endif

// The vertex shader will give us this.
varying vec2 xyPos;

// Pixel size of the canvas.
uniform vec2 resolution;

// tex0 is our image.
uniform sampler2D tex0;

// Entry point for shaders.
void main(void) {
    // Color of the current pixel in (r,g,b,a).
    vec4 o = texture2D(tex0, xyPos);

    // Give our result to WebGL.
    gl_FragColor = o;
}
    </script>

    <script id="negative-fs" type="shader-fs">
#ifdef GL_ES
precision highp float;
#endif

varying vec2 xyPos;
uniform vec2 resolution;
uniform sampler2D tex0;

void main(void) {
    vec4 o = texture2D(tex0, xyPos);

    // In WebGL all color values are from 0 to 1.
    vec3 white = vec3(1.0, 1.0, 1.0);

    vec3 negative = white - o.rgb;

    // Return fully opaque.
    gl_FragColor = vec4(negative, 1.0);
}
    </script>

    <script id="bw-fs" type="shader-fs">
#ifdef GL_ES
precision highp float;
#endif

varying vec2 xyPos;
uniform vec2 resolution;
uniform sampler2D tex0;

void main(void) {
    vec4 o = texture2D(tex0, xyPos);

    // Calculate average.
    float average = (o.r+o.g+o.b)/3.0;

    // Set all channels to the same value.
    vec3 bw = vec3(average);
        
    gl_FragColor = vec4(bw, 1.0);
}
    </script>

    <script type="text/javascript" src="lib/jquery-1.6.1.js"></script>
    <script type="text/javascript" src="jquery.gl_shaderer.js"></script>

    <script type="text/javascript">

        $(function () {

            function initialize(images) {
                $("#webgl-canvas-normal").gl_shadered({
                    images: images,
                    fragmentShaders: [$("#plain-fs").html()]
                });

                $("#webgl-canvas-negative").gl_shadered({
                    images: images,
                    fragmentShaders: [$("#negative-fs").html()]
                });

                $("#webgl-canvas-bw").gl_shadered({
                    images: images,
                    fragmentShaders: [$("#bw-fs").html()]
                });
            }

            $("#plain-fs-code").html($("#plain-fs").text());
            $("#negative-fs-code").html($("#negative-fs").text());
            $("#bw-fs-code").html($("#bw-fs").text());

            var textureUrls = ["images/IMG_2273.JPG", "images/IMG_2235.JPG", "images/burn3.png"];
            $.fn.gl_shadered.loadImages(textureUrls, initialize);
        });

    </script>

    </head>
    <body>
        <div id="content-wrapper">
            <div id="content">
                <h1>Fragment Shader Gallery</h1>
                <div class="intro">
                    <p>WebGL shaders give you the power to manipulate pixels freely in real-time. The code you write for processing one pixel is executed for every single one of them. Shaders give possibilities far beyond anything else known to web browsers so far.</p>
                    <p>However, everything comes at a price. You have to use a C-like shader language, instead of the friendly old JavaScript. Writing shaders can be a bit&mdash;a lot&mdash;scary, but fortunately the number of lines you have to write to produce sweet results is negligible.</p>
                    <p>Lastly, while most modern <b>real</b> browsers do support WebGL, there is a chance that it will never work on Internet Explorer. Or mobile.</p>
                </div>

                <div class="hr"></div>
                <div>
                    <div class="left">
                        <canvas id="webgl-canvas-normal" class="webgl-canvas"></canvas>
                    </div>
                    <div class="paragraph">
                        <h2>Starting point</h2>
                        <p>This is the image we will use.</p>
                        <p>For all shaders here, we use a simple <b>vertex shader</b> that does not do much. Normally a vertex shader could be used to transform the vertices of the underlying 3D model. This would include, for instance, scaling or rotating them.</p>
                        <p>Since we only want to render 2D images, we use a simple plane that covers the whole canvas. We save the coordinate of the plane we are processing in texturePos.</p>
                        <pre id="plain-fs-code"></pre>
                    </div>
                </div>

                <div class="hr"></div>

                <div>
                    <div class="left">
                        <canvas id="webgl-canvas-negative" class="webgl-canvas"></canvas>
                    </div>
                    <div class="paragraph">
                        <h2>Negative</h2>
                        <pre id="negative-fs-code"></pre>
                    </div>
                </div>

                <div class="hr"></div>

                <div>
                    <div class="left">
                        <canvas id="webgl-canvas-bw" class="webgl-canvas"></canvas>
                    </div>
                    <div class="paragraph">
                        <h2>Black and white (linear)</h2>
                        <pre id="bw-fs-code"></pre>
                    </div>
                </div>

                <div class="hr"></div>

            </div>
            <span class="footer"><a href="http://github.com/tehmou">@Github</a></span>
        </div>
    </body>
</html>